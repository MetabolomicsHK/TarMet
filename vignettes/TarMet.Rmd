---
title: "TarMet"
author: "Hongchao Ji"
date: "2018/1/2"
package: TarMet
output:
  BiocStyle::html_document:
    toc_float: true
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Targeted metabolic analyses based on mass spectrometry}
  %\VignetteKeywords{mass spectrometry, metabolomics}
  %\VignetteEncoding{UTF-8}
  %\VignettePackage{TarMet}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
TarMet is a shiny application for targeted metabolic analyses based on mass spectrometry. TarMet can detect all of the isotopologues of target metabolites, and quantify the metabolites based on the peak areas automatically and efficiently.

# Functions
In this section, it will be described how TarMet process the MS dataset. it will also introduce what the parameters represent, and how to set them. Although, for the end user, all of the functions can be used in the shiny app, the backend funtions will also be described here. Now, we use *mtbls2* dataset as an example.
```{r example_data, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
library(TarMet)
library(mtbls2)
filepath <- file.path(find.package("mtbls2"), "mzData")
files <- file.path(filepath, list.files(filepath, recursive = TRUE))[1:3] # A set of files
file1 <- files[1] # one file, which is used for isotopic analysis
```

## Isotopic Analysis
Isotopic analysis is meanly used for extracting the isotope peaks of the targeted compound. The purposes is either find the isotope pattern of the targeted compound (for example isotopic labeling assay, or annoatating formula of unknown compound) or use the isotope pattern to locating the retention time (when more than one peak in an EIC).

### Upload Raw Data
TarMet uses *mzR* to parse raw data. The upload files can be *mzML*, *mzXML*, *mzData* or *CDF* format. Only one file can be upload in the isotope analysis step. The peak detection results of this file will be regard as the reference in the subsequent steps. When you process dataset of multiple classes, a QC sample is recommand to be upload in this step. After upload, TarMet will read the information with *LoadData* function:
```{r load_data1, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
raw <- LoadData(file1)
rawfiles <- lapply(files, LoadData)
```

### Metabolite Information
The matabolite can be input as formulas or monoisotopic mass. 
If you choose to input a formula. You can select which kinds of adduct to be detected. Usually *M+H*, *M+Na* and *M+K* are common in positive mode, while *M-H* and *M+Cl* are common in negative mode. You should also give the threshold of relative abundance, and only peaks above the threshold are under consideration. The isotope pattern will be calculated by *getIsoPat* function:
```{r cal_isotope, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
pattern <- getIsoPat('C16H12O5', 'M+H', 0.2, 50000)
```
If you choose to input the targeted ion, TarMet will directly use the targeted m/z for the EIC extraction. This mode is usually used when the formula is unknow. You should give the possible charge of the ion for locating the m/z isotope peaks.

### EIC Extraction
The extraction ion chromatograms are obtained by sum the data points within a specific m/z tolerance, given as ppm. You can also choose to remove the baseline via airPLS algorithm. 
If you input metabolite information by giving the m/z, the EICs will be extracted by *getIsoEIC.mz* function:
```{r get_eic_mz, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
eics <- getIsoEIC.mz(raw,  fmz= 201.04, ppm=100)
```
If you input metabolite information by giving the formula, the EICs will be extracted by *getIsoEIC.formula* function:
```{r get_eic_formula, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
eics1 <- getIsoEIC.formula(raw, formula='C16H12O5', adduct='M+H', ppm=100)
```
After Extraction, the EICs will be plot in the main panel via *plotEICs* function:
```{r plot_eic_mz, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
plotEICs(eics)
```

### Peak Detection
The peak detection is based on *MassSpecWavelet* package. Three parameters should be given, which are the minimum snrs, minimum scales of peaks and minimum intensities of peaks. Besides, the peak bound of each peak will also be calculated, which is used for calculated the peak area.
```{r peak_dec, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
peaks <- getIsoPeaks(eics, SNR.Th = 4, peakScaleRange = 5)
```
After peak detection, if there are peaks in the extracted EICs, the the information will be added in the EIC plot, and the peak information will be shown below the plot.
```{r peak_info, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
plotEICs(eics, peaks)
peaks$PeakInfo
peaks$PeakArea
```

### Alignment
For a set of samples, the EICs are obtained by 
```{r get_eic_files, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
mzrange <- eics$mzs[1, ] # choose the first isotope feature, it can be adjusted in the app. 
files_eics <- lapply(rawfiles, function(raw){
  getEIC.mz(raw, c(0, Inf), mzrange)
})
```
Usually, retention time of the same metabolite may differs between different samples. You can choose whether to correct the time shift. If you choose to align the samples, you should also give the maximum tolerence time shifts. TarMet do this step with the following code:
```{r alignment, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
rt <- eics$eics[[1]]$rt # obtain the rt list of the reference data file, which is used for interpolation.
align.seg <- 150; align.shift <- 150 # parameters of alignment, which can be adjusted in the app.
eic <- eics$eics[[1]] # obtain the first isotope EIC of the reference data file, which is used for interpolation.
for (i in 1:length(files_eics)){
  # interpolation
  intensity.new <- approx(x=files_eics[[i]]$rt, y=files_eics[[i]]$intensity, xout=rt, rule = 2)$y
  # remove baseline (optional)
  intensity.new <- intensity.new - airPLS(intensity.new) 
  # alignment (optional)
  intensity.new <- PAFFT(t(intensity.new), t(eic$intensity), 
                         align.seg, align.shift)$alignedSpectrum
  files_eics[[i]]$intensity <- as.numeric(intensity.new)
  files_eics[[i]]$rt <- rt
}
plotEICs(list(eics=files_eics), Names=Names)
```

### Quantitative Result
Finally, the quantitative results will be shown in the main panel below the EICs, which are calculated by:
```{r quan_result, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
target_left <- 620; target_right <- 640 # peak bounds, either given by user or set based on the peak detection result automatically.
Areas <- sapply(files_eics, function(eics){
  eics <- list(rt=rt, eics=list(eics))
  getArea(eics, target_left, target_right)
})
Areas <- round(Areas, 3)
Areas
```

<<<<<<< HEAD
## Swath-MS Analysis
In this section, the input dataset must be obtained in Swath-MS mode. In contrast to traditional data-dependent MS/MS acquisitions, Swath-MS is a data independent method which can obtain all fragment ions for all precursors simultaneously, thereby increasing the coverage of observable molecules and reducing the identification of false negatives. In TarMet, the swath-ms analysis is followed by the *Isotopic Analysis*, thus, the analysis are based on the previous results. However, for ensure the integrality, they are also included in this section.

### Load Swath-MS data files.
Since the Swath-MS data files are too big, one targeted ion is selected as an example. The related data has been save in this package. which are obtained by the following codes.
```{r ref_swath, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
# load raw data
swath_files <- list.files('F:/DIA_demo', full.names = TRUE)
swath_files_raw <- lapply(swath_files, LoadSwath)
# load MS1 and MS2 of the targeted compound
tar_mz <- 935.5868
swath_files_ms1 <- lapply(swath_files, LoadData)
swath_files_ms2 <- lapply(swath_files_raw, function(r){
  getSwathData(r, tar_mz)
})
```

### Extracting EICs of fragment ions.
To get the EICs of fragment ions, the mzs of fragment ions should be defined. In the *Isotopic Analysis* step, we have defined the peak position and peak bounds. Thus, TarMet uses the mzs mass spectrum in that retention time. This is done by the *getSwathMz* function. Then, TarMet extracts EICs of fragment ion of the reference data file first. Here are the steps in details:

```{r mz_swath, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
# 1. Get MS1 EICs
ppm <- 50
swath_files_ms1_eics <- lapply(swath_files_ms1, function(f){
  getIsoEIC.mz(f, tar_mz, nmax = 1, ppm = ppm)
})

# 2. Select the a sample as reference, and detect peak position basing on ms1
swath_ref_ms1_eics <- swath_files_ms1_eics[[1]]
swath_ref_ms2 <- swath_files_ms2[[1]]
swath_ref_peaks <- getIsoPeaks(swath_ref_ms1_eics)

# 3. Define the peak position and bounds based on the peak detection results, and find the m/z of the fragment ions
tar_position <- 282; tar_left <- 277.9; tar_right <- 288.5
swath_mz <- getSwathMz(swath_ref_ms2, tar_position, ppm)

# 4. Get the EICs based on the m/z of fragment ions
swath_files_ms2_eics <- lapply(swath_files_ms2, function(f){
  getSwathEICs(f, swath_mz, ppm)
})

```

### Refine fragment ions based in peak profiles.
Generally, the fragment ions are produced at the same time as the precursor ion, therefore, the peak profiles of the fragment ions should be similar to the profile of the precursor ion. TarMet refine the EICs based on correlation between the fragment ions and the precursor ion. The codes are:
```{r frag_refine, eval=TRUE, cache=TRUE, message=FALSE, warning=FALSE}

```

=======
>>>>>>> master

